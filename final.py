# -*- coding: utf-8 -*-
"""final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VkZ0b_uyTTjwHaSGcRpc1oOTXWetnBDx
"""

import pandas
import numpy
import pickle
import tensorflow
import pandas as pd
import numpy as np
from tensorflow.keras.utils import to_categorical
from sklearn.model_selection import train_test_split

class final:
  """ this class has 2 functions namely train_test_results, takes whole data as input and returns test, train pd results,
      and predict, takes query point(s) as input and returns the corrosponding emotional word such as sad, fear etc. However, init function of this class
      takes minmax, label encoder and model filepaths for the use. """

  def __init__(self, minmax_path, lb_filepath, model_filepath ):

     """constructer with trained cnn model, minmax and label_encoder model filepaths"""

     #loading trained label_encoder to transform y_train, y_test
     self.lb = pickle.load(open(lb_filepath, 'rb'))

     #loading minmax scaler to transform x_train, x_test
     self.scaler = pickle.load(open(minmax_path, 'rb'))    
      
     #loading CNN 1D model
     self.model = tensorflow.keras.models.load_model(model_filepath)

  def train_test_results(self, df_path):
    """this function takes input of the whole data and predicts the outcome of x_train and x_test using 1D CNN model. Data can either be in csv or json format"""

    self.df_format = df_path.split('.')[1]

    if self.df_format== 'csv':
      #load data, the preprocessed data with engineered features
      self.df_new = pd.read_csv(df_path)

    elif self.df_format == 'json':
      self.df_new = pd.read_json(df_path)

    else:
      raise Exception('kindly use either csv or json format')

    #getting class labels
    self.class_label = self.df_new['emotions']
    
    #reomving class label and filepath
    self.df_final= self.df_new.drop(columns= ['Unnamed: 0','emotions', 'path'])
    """print(self.df_final.shape)"""

    #getting x_train, x_test, y_train, y_test
    self.x_train, self.x_test, self.y_train, self.y_test = train_test_split(self.df_final, self.class_label, test_size=0.20, stratify= self.class_label)

    #fitting label_encoder to transform y_train, y_test
    self.y_train = to_categorical(self.lb.transform(self.y_train))
    self.y_test = to_categorical(self.lb.transform(self.y_test))
  
    #fitting minmax scaler 
    self.x_train = self.scaler.transform(self.x_train)
    self.x_test = self.scaler.transform(self.x_test)

    #adding new axis for dl model
    self.x_train = self.x_train[:,:,np.newaxis]
    self.x_test = self.x_test[:,:,np.newaxis]

    #prediction train and test
    self.y_pred_tr = self.model.predict(self.x_train)
    self.y_pred_te = self.model.predict(self.x_test)

    # converting y_pred into actual classes for CNN
    self.y_pred= self.y_pred_te.argmax(axis=1)
    self.y_pred = self.y_pred.astype(int)

    self.y_pred = (self.lb.inverse_transform((self.y_pred)))

    #original y_pred df
    self.prediction = pd.DataFrame({'prediction': self.y_pred})

    #converting y_true into original labels for CNN
    self.y_true = self.y_test.argmax(axis=1)
    self.y_true = self.y_true.astype(int)
    self.y_true = (self.lb.inverse_transform((self.y_true)))

    #original y_test df
    self.actual = pd.DataFrame({'actual': self.y_true})

    print(self.prediction.head(),'\n', '\n', self.actual.head())

  def predict(self, query):
    """ This function takes a floating numerical input of matrix/list/array/vector of any number of rows but Columns need to be 141.
        Output(s) are emotional word(s) from 8 emotions: angry, fear, happy, sad, disgust, calm, neutral or surprised """

    self.query= query

    if isinstance(self.query, (pandas.core.frame.DataFrame, list, numpy.ndarray))==False:
      raise TypeError("Only arrays, lists or dataframes are allowed")

    if type(self.query)== pandas.core.frame.DataFrame:
      if self.query.dtypes.all() != 'float64':
        raise Exception("Only floating numbers are allowed")
      
      elif self.query.shape[1] != 141:
        raise Exception("only 141 columns are allowed")

    if type(self.query)== numpy.ndarray:
      if self.query.dtype != 'float64':
        raise Exception("Only floating numbers are allowed")

      elif self.query.shape[1] != 141:
        raise Exception("only 141 columns are allowed")
    
    if type(self.query)== list:
      if type(self.query[0][0]) != float:
        raise Exception("Only floating numbers are allowed")
      
      elif len(self.query[0]) != 141:
        raise Exception("only 141 row length allowed")


    self.query = self.scaler.transform(self.query)
    #print('self.query scaler', self.query.shape)

    self.query = self.query[:,:,np.newaxis]
    #print('axis', self.query.shape)

    self.query = self.model.predict(self.query)
    #print('self.query predict', self.query)
    #print('prediction done')

    self.query = self.query.argmax(axis=1)
    self.query = self.query.astype(int)
    self.output= (self.lb.inverse_transform((self.query)))

    return  self.output